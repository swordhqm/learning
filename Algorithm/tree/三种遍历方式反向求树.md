# 三种遍历方式反向求树

```
abcabg 只给中序，构造的两种可满足树
<1>
        b
   a        a
        c        g
            b
<2>
            b
        a        g    
    b
 a      c

abcabg    中    <1> <2> 满足
babacg    先    <2> 满足
acbagb    后    <2> 满足

给定中序遍历和 前，后两个中的一个都可以确定树结构
```

```
一个前序遍历序列和一个中序遍历序列可以确定一颗唯一的二叉树。

根据前序遍历的特点, 知前序序列(PreSequence)的首个元素(PreSequence[0])为二叉树的根(root),  
然后在中序序列(InSequence)中查找此根(root),  
根据中序遍历特点, 知在查找到的根(root) 前边的序列为根的左子树的中序遍历序列,  后边的序列为根的右子树的中序遍历序列。
设在中序遍历序列(InSequence)根前边有left个元素. 则在前序序列(PreSequence)中, 
紧跟着根(root)的left个元素序列(即PreSequence[1...left]) 为根的左子树的前序遍历序列, 在后边的为根的右子树的前序遍历序列.
而构造左子树问题其实跟构造整个二叉树问题一样，只是此时前序序列为PreSequence[1...left]), 中序序列为InSequence[0...left-1], 
分别为原序列的子串, 构造右子树同样, 显然可以用递归方法解决。
每次将根结点的数据赋值，然后不断的递归调用创建左右子树，直到不存在左右子树时函数返回。
```



